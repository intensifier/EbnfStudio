/*
* Copyright 2019 Rochus Keller <mailto:me@rochus-keller.ch>
*
* This file is part of the EbnfStudio application.
*
* The following is the license that applies to this copy of the
* application. For a license to use the application under conditions
* other than those described here, please email to me@rochus-keller.ch.
*
* GNU General Public License Usage
* This file may be used under the terms of the GNU General Public
* License (GPL) versions 2.0 or 3.0 as published by the Free Software
* Foundation and appearing in the file LICENSE.GPL included in
* the packaging of this file. Please review the following information
* to ensure GNU General Public Licensing requirements will be met:
* http://www.fsf.org/licensing/licenses/info/GPLv2.html and
* http://www.gnu.org/copyleft/gpl.html.
*/

#include "CocoGen.h"
#include "EbnfAnalyzer.h"
#include "FirstFollowSet.h"
#include "GenUtils.h"
#include "LaParser.h"
#include "SynTreeGen.h"
#include <QFile>
#include <QTextStream>
#include <QtDebug>

CocoGen::CocoGen():d_tbl(0)
{

}

bool CocoGen::generate(const QString& atgPath, EbnfSyntax* syn, FirstFollowSet* tbl, bool buildAst )
{
    // see http://ssw.jku.at/Coco/

    if( syn == 0 || syn->getOrderedDefs().isEmpty() )
        return false;

    Q_ASSERT( syn != 0 );

    const QString nameSpace = syn->getPragmaFirst("%namespace").toStr();
    const QString nameSpace2 = nameSpace.isEmpty() ? nameSpace : ( nameSpace + "::" );
    QString module = syn->getPragmaFirst("%module").toStr();
    if( !module.isEmpty() )
        module = module + "/";
    const EbnfSyntax::SymList suppress = syn->getPragma("%suppress");
    const bool parentPtr = !syn->getPragmaFirst("%parentptr").isEmpty();

    d_tbl = tbl;
    d_syn = syn;

    const EbnfSyntax::Definition* root = syn->getOrderedDefs()[0];

    QFile f(atgPath);
    f.open( QIODevice::WriteOnly );
    QTextStream out(&f);
    out.setCodec("utf-8");

    out << "// This file was automatically generated by EbnfStudio; don't modify it!" << endl;
    if( buildAst )
    {
        out << "#include <QStack>" << endl;
        out << "#include <" << module << nameSpace << "SynTree.h>" << endl;
        out << "COMPILER " << root->d_tok.d_val.toStr() << endl;

        out << endl;


        out << "\t" << nameSpace2 << "SynTree d_root;" << endl;
        out << "\tQStack<" << nameSpace2 << "SynTree*> d_stack;" << endl;

        out << "\t" << "void addTerminal() {" << endl;

        if( !suppress.isEmpty() )
        {
            out << "\t\t" << "if( ";
            for( int i = 0; i < suppress.size(); i++ )
                out << ( i == 0 ? "" : "&& " ) << "d_cur.d_type != " << nameSpace2 << "Tok_"
                    << GenUtils::symToString(suppress[i].toStr()) << " ";
            out << "){" << endl << "\t";
        }
        out << "\t\t" << nameSpace2 << "SynTree* n = new " <<
               nameSpace2 << "SynTree( d_cur ); d_stack.top()->d_children.append(n);"
            << ( parentPtr ? " n->d_parent = d_stack.top();" : "" ) << endl;
        if( !suppress.isEmpty() )
            out << "\t\t}" << endl;
        out << "\t}" << endl;

    }
    out << endl;

    out << "TOKENS" << endl;

    SynTreeGen::TokenNameValueList tokens = SynTreeGen::generateTokenList(syn);

    for( int t = 0; t < tokens.size(); t++ )
    {
        out << "  " << tokenName(tokens[t].first);
        if( tokens[t].second.isEmpty() )
            out << "_";
        out << endl;
    }
    out << endl;

    out << "PRODUCTIONS" << endl;
    out << endl;

    // Fall i=0
    if( !syn->getOrderedDefs().isEmpty() )
    {
        const EbnfSyntax::Definition* d = syn->getOrderedDefs().first();
        out << GenUtils::escapeDollars( d->d_tok.d_val.toStr() ) << " = " << endl << "    ";
        if( buildAst )
            out << "(. d_stack.push(&d_root); .) (";
        writeNode( out, d->d_node, true, buildAst );
        if( buildAst )
            out << ") (. d_stack.pop(); .) ";
        out << endl << "    ." << endl << endl;
    }

    // Fall i>0
    for( int i = 1; i < syn->getOrderedDefs().size(); i++ )
    {
        const EbnfSyntax::Definition* d = syn->getOrderedDefs()[i];

        if( d->d_tok.d_op == EbnfToken::Skip || ( i != 0 && d->d_usedBy.isEmpty() ) )
            continue;
        if( d->d_node == 0 )
            continue;

        out << GenUtils::escapeDollars( d->d_tok.d_val.toStr() ) << " = " << endl << "    ";
        const bool transparent = d->d_tok.d_op == EbnfToken::Transparent;
        if( buildAst && !transparent )
            out << "(. " << nameSpace2 << "SynTree* n = new " << nameSpace2 << "SynTree( " <<
                   nameSpace2 << "SynTree::R_" << GenUtils::escapeDollars( d->d_tok.d_val.toStr() ) <<
                   ", d_next ); d_stack.top()->d_children.append(n);"
                << ( parentPtr ? " n->d_parent = d_stack.top();" : "" ) << " d_stack.push(n); .) ( ";
        writeNode( out, d->d_node, true, buildAst );

        if( buildAst && !transparent )
            out << ") (. d_stack.pop(); .) ";

        out << endl << "    ." << endl << endl;
    }

    out << "END " << root->d_tok.d_val.toStr() << " ." << endl;
    return true;
}

void CocoGen::writeNode( QTextStream& out, EbnfSyntax::Node* node, bool topLevel, bool buildAst )
{
    if( node == 0 )
        return;

    if( node->d_tok.d_op == EbnfToken::Skip )
        return;
    if( node->d_def && node->d_def->d_tok.d_op == EbnfToken::Skip )
        return;

    switch( node->d_quant )
    {
    case EbnfSyntax::Node::One:
        if( !topLevel && node->d_type == EbnfSyntax::Node::Alternative )
            out << "( ";
        else if( !topLevel && node->d_type == EbnfSyntax::Node::Sequence && !node->d_tok.d_val.isEmpty() )
            out << "( ";
        break;
    case EbnfSyntax::Node::ZeroOrOne:
        out << "[ ";
        break;
    case EbnfSyntax::Node::ZeroOrMore:
        out << "{ ";
        break;
    }

    switch( node->d_type )
    {
    case EbnfSyntax::Node::Terminal:
        out << tokenName( node->d_tok.d_val.toStr() ) << " ";
        if( buildAst )
            out << "(. addTerminal(); .) ";
        break;
    case EbnfSyntax::Node::Nonterminal:
        if( node->d_def == 0 || node->d_def->d_node == 0 )
        {
            // pseudoterminal
            out << tokenName(node->d_tok.d_val.toStr()) << " ";
            if( buildAst )
                out << "(. addTerminal(); .) ";
        }else
            out << GenUtils::escapeDollars(node->d_tok.d_val.toStr()) << " ";
        break;
    case EbnfSyntax::Node::Alternative:
        for( int i = 0; i < node->d_subs.size(); i++ )
        {
            if( i != 0 )
            {
                if( topLevel )
                    out << endl << "    | ";
                else
                    out << "| ";
            }
            writeNode( out, node->d_subs[i], false, buildAst );
        }
        break;
    case EbnfSyntax::Node::Sequence:
        for( int i = 0; i < node->d_subs.size(); i++ )
        {
            if( node->d_subs[i]->d_type == EbnfSyntax::Node::Predicate )
                handlePredicate( out, node->d_subs[i], node );
            else
                writeNode( out, node->d_subs[i], false, buildAst );
        }
        break;
    case EbnfSyntax::Node::Predicate:
        qWarning() << "Coco::writeNode: EbnfSyntax::Node::Predicate";
        break;
    }
    switch( node->d_quant )
    {
    case EbnfSyntax::Node::One:
        if( !topLevel && node->d_type == EbnfSyntax::Node::Alternative )
            out << ") ";
        else if( !topLevel && node->d_type == EbnfSyntax::Node::Sequence && !node->d_tok.d_val.isEmpty() )
            out << ") ";
        break;
    case EbnfSyntax::Node::ZeroOrOne:
        out << "] ";
        break;
    case EbnfSyntax::Node::ZeroOrMore:
        out << "} ";
        break;
    }
}

static void renderLaSub( QTextStream& out, const LaParser::Ast* ast, EbnfSyntax* syn, int la )
{
    switch( ast->d_type )
    {
    case LaParser::Ast::Ident:
    case LaParser::Ast::Literal:
        out << "peek(" << la << ") == _" << "T_" << GenUtils::symToString(ast->d_val) << " ";
        break;
    case LaParser::Ast::Not:
        out << "!( ";
        renderLaSub(out,ast->d_subs.first().data(),syn,la);
        out << ") ";
        break;
    case LaParser::Ast::Or:
        if( ast->d_subs.size() > 1 )
            out << "( ";
        for( int i = 0; i < ast->d_subs.size(); i++ )
        {
             if( i != 0 )
                 out << "|| ";
             renderLaSub(out,ast->d_subs[i].data(),syn, la);
        }
        if( ast->d_subs.size() > 1 )
            out << ") ";
        break;
    case LaParser::Ast::And:
        for( int i = 0; i < ast->d_subs.size(); i++ )
        {
             if( i != 0 )
                 out << "&& ";
             renderLaSub(out,ast->d_subs[i].data(),syn,la);
        }
        break;
    default:
        Q_ASSERT( false );
        break;
    }
}

static void renderLaExpr( QTextStream& out, const LaParser::Ast* ast, EbnfSyntax* syn )
{
    switch( ast->d_type )
    {
    case LaParser::Ast::La:
        renderLaSub( out,ast->d_subs.first().data(),syn,ast->d_val.toInt() );
        break;
    case LaParser::Ast::Or:
        if( ast->d_subs.size() > 1 )
            out << "( ";
        for( int i = 0; i < ast->d_subs.size(); i++ )
        {
             if( i != 0 )
                 out << "|| ";
             renderLaExpr(out,ast->d_subs[i].data(),syn);
        }
        if( ast->d_subs.size() > 1 )
            out << ") ";
        break;
    case LaParser::Ast::And:
        for( int i = 0; i < ast->d_subs.size(); i++ )
        {
             if( i != 0 )
                 out << "&& ";
             renderLaExpr(out,ast->d_subs[i].data(),syn);
        }
        break;
    default:
        Q_ASSERT( false );
        break;
    }
}

void CocoGen::handlePredicate(QTextStream& out,EbnfSyntax::Node* pred, EbnfSyntax::Node* sequence)
{
    const QByteArray la = pred->getLa();
    if( !la.isEmpty() )
    {
        LaParser p;
        if( !p.parse(la) )
            return; // error was already reported

        out << "IF( ";
        renderLaExpr( out, p.getLaExpr().constData(), d_syn );
        out << ") ";

        return;
    }
    const int ll = pred->getLlk();
    if( ll > 0 )
    {
        EbnfAnalyzer::LlkNodes llkNodes;
        EbnfAnalyzer::calcLlkFirstSet( ll, llkNodes,sequence, d_tbl );
        //EbnfAnalyzer::calcLlkFirstSet2( ll, llkNodes,sequence, d_tbl );
        out << "IF( ";
        for( int i = 0; i < llkNodes.size(); i++ )
        {
            if( i != 0 )
                out << "&& ";
            if( llkNodes[i].size() > 1 )
                out << "( ";
            QStringList names;
            EbnfSyntax::NodeRefSet::const_iterator j;
            for( j = llkNodes[i].begin(); j != llkNodes[i].end(); ++j )
                names << tokenName( (*j).d_node->d_tok.d_val.toStr() );
            names.sort(Qt::CaseInsensitive);
            for( int j = 0; j < names.size(); j++ )
            {
                if( j != 0 )
                    out << "|| ";
                out << "peek(" << i+1 << ") == _" << names[j] << " ";
            }
            if( llkNodes[i].size() > 1 )
                out << ") ";
        }
        out << ") ";
    }else
        qWarning() << "CocoGen unknown predicate" << sequence->d_tok.d_val.toStr();
}

QString CocoGen::tokenName(const QString& str)
{
    return QLatin1String("T_") + GenUtils::symToString(str);
}
