/*
* Copyright 2023 Rochus Keller <mailto:me@rochus-keller.ch>
*
* This file is part of the EbnfStudio application.
*
* The following is the license that applies to this copy of the
* application. For a license to use the application under conditions
* other than those described here, please email to me@rochus-keller.ch.
*
* GNU General Public License Usage
* This file may be used under the terms of the GNU General Public
* License (GPL) versions 2.0 or 3.0 as published by the Free Software
* Foundation and appearing in the file LICENSE.GPL included in
* the packaging of this file. Please review the following information
* to ensure GNU General Public Licensing requirements will be met:
* http://www.fsf.org/licensing/licenses/info/GPLv2.html and
* http://www.gnu.org/copyleft/gpl.html.
*/

#include "CppGen.h"
#include "GenUtils.h"
#include "FirstFollowSet.h"
#include "EbnfAnalyzer.h"
#include "LaParser.h"
#include <QFile>
#include <QTextStream>
#include <QDir>
#include <QtDebug>

CppGen::CppGen()
{

}

bool CppGen::generate(const QString& ebnfPath, EbnfSyntax* syn, FirstFollowSet* tbl)
{
    if( syn == 0 || syn->getOrderedDefs().isEmpty() )
        return false;

    Q_ASSERT( syn != 0 );
    tbl->setSyntax(syn);

    const QByteArray nameSpace = syn->getPragmaFirst("%namespace").toBa();
    const QByteArray nameSpace2 = nameSpace.isEmpty() ? nameSpace : ( nameSpace + "::" );
    QString module = syn->getPragmaFirst("%module").toStr();
    if( !module.isEmpty() )
        module = module + "/";
    const EbnfSyntax::SymList suppress = syn->getPragma("%suppress");

    d_tbl = tbl;
    d_syn = syn;

    const Ast::Definition* root = syn->getOrderedDefs()[0];

    QDir dir = QFileInfo(ebnfPath).dir();

    QFile header( dir.absoluteFilePath( nameSpace + "Parser.h") );
    header.open( QIODevice::WriteOnly );
    QTextStream hout(&header);
    hout.setCodec("utf-8");

    const QByteArray stopLabel = "__" + nameSpace.toUpper() + ( !nameSpace.isEmpty() ? "_" : "" ) + "PARSER__";
    hout << "#ifndef " << stopLabel << endl;
    hout << "#define " << stopLabel << endl;
    hout << "// This file was automatically generated by EbnfStudio; don't modify it!" << endl;
    hout << endl;
    hout << "#include <" << module << nameSpace << "SynTree.h>" << endl;
    hout << endl;

    if( !nameSpace.isEmpty() )
        hout << "namespace " << nameSpace << " {" << endl;

    hout << endl;
    hout << "\t" << "class Scanner {" << endl;
    hout << "\t" << "public:" << endl;
    hout << "\t\t" << "virtual Token next() = 0;" << endl;
    hout << "\t\t" << "virtual Token peek(int offset) = 0;" << endl;
    hout << "\t" << "};" << endl << endl;

    hout << "\t" << "class Parser {" << endl;
    hout << "\t" << "public:" << endl;
    hout << "\t\t" << "Parser(Scanner* s):scanner(s) {}" << endl;
    hout << "\t\t" << "void RunParser();" << endl;
    hout << "\t\t" << "SynTree root;" << endl;
    hout << "\t\t" << "struct Error {" << endl;
    hout << "\t\t" << "    QString msg;" << endl;
    hout << "\t\t" << "    int row, col;" << endl;
    hout << "\t\t" << "    QString path;" << endl;
    hout << "\t\t" << "    Error( const QString& m, int r, int c, const QString& p)"
            ":msg(m),row(r),col(c),path(p){}" << endl;
    hout << "\t\t" << "};" << endl;
    hout << "\t\t" << "QList<Error> errors;" << endl;

    hout << "\t" << "protected:" << endl;
    for( int i = 0; i < syn->getOrderedDefs().size(); i++ )
    {
        const Ast::Definition* d = syn->getOrderedDefs()[i];

        if( d->d_tok.d_op == EbnfToken::Skip || ( i != 0 && d->d_usedBy.isEmpty() ) )
            continue;
        if( d->d_node == 0 || d->d_tok.d_op == EbnfToken::Transparent )
            continue;

        hout << "\t\t" << "void " << d->d_tok.d_val.toStr() << "(SynTree*);" << endl;
    }

    hout << "\t" << "protected:" << endl;
    hout << "\t\t" << "Token cur;" << endl;
    hout << "\t\t" << "Token la;" << endl;
    hout << "\t\t" << "Scanner* scanner;" << endl;
    hout << "\t\t" << "void next();" << endl;
    hout << "\t\t" << "int peek(int off);" << endl;
    hout << "\t\t" << "void invalid(const char* what);" << endl;
    hout << "\t\t" << "void expect(int tt, const char* where);" << endl;

    hout << "\t" << "};" << endl;

    if( !nameSpace.isEmpty() )
        hout << "}" << endl;

    hout << "#endif // include" << endl;

    QFile body( dir.absoluteFilePath( nameSpace + "Parser.cpp") );
    body.open( QIODevice::WriteOnly );
    QTextStream bout(&body);
    bout.setCodec("utf-8");

    bout << "// This file was automatically generated by EbnfStudio; don't modify it!" << endl;
    bout << "#include \"" << nameSpace << "Parser.h\"" << endl;
    if( !nameSpace.isEmpty() )
        bout << "using namespace " << nameSpace << ";" << endl;
    bout << endl;

    for( int i = 0; i < syn->getOrderedDefs().size(); i++ )
    {
        const Ast::Definition* d = syn->getOrderedDefs()[i];

        if( d->d_tok.d_op == EbnfToken::Skip || ( i != 0 && d->d_usedBy.isEmpty() ) )
            continue;
        if( d->d_node == 0  || d->d_tok.d_op == EbnfToken::Transparent )
            continue;

        bout << "static inline bool FIRST_" << d->d_tok.d_val.toStr() << "(int tt) {" << endl;
        //EbnfAnalyzer::LlkNodes firsts;
        //EbnfAnalyzer::calcLlkFirstSet(1,firsts,d->d_node,tbl);
        Ast::NodeRefSet ns = tbl->getFirstSet(d->d_node);
#if 0
        const bool same = firsts.first() == ns;
        if( !same )
        {
            qDebug() << "diff in" << d->d_tok.d_val.toBa().constData() << ns.size() << firsts.first().size();
            QStringList sort;
            Ast::NodeRefSet::const_iterator j;
            for( j = ns.begin(); j != ns.end(); ++j )
                sort << (*j).d_node->d_tok.d_val.toStr();
            sort.sort(Qt::CaseInsensitive);
            qDebug() << sort.join(' ');
            sort.clear();
            for( j = firsts.first().begin(); j != firsts.first().end(); ++j )
                sort << (*j).d_node->d_tok.d_val.toStr();
            sort.sort(Qt::CaseInsensitive);
            qDebug() << sort.join(' ');
        }
#endif
#if 0
        qDebug() << d->d_tok.d_val.toBa();
        QStringList sort;
        Ast::NodeRefSet::const_iterator j;
        for( j = ns.begin(); j != ns.end(); ++j )
            sort << "T_"+GenUtils::symToString((*j).d_node->d_tok.d_val.toStr());
        sort.sort(Qt::CaseInsensitive);
        qDebug() << "First:" << sort.join(' ');
        sort.clear();
        Ast::NodeRefSet follow = tbl->getFollowSet(d->d_node);
        for( j = follow.begin(); j != follow.end(); ++j )
            sort << "T_"+GenUtils::symToString((*j).d_node->d_tok.d_val.toStr());
        sort.sort(Qt::CaseInsensitive);
        qDebug() << "Follow:" << sort.join(' ');
        qDebug() << "";
#endif
        if( ns.isEmpty() )
            bout << "\t" << "return false;" << endl;
        else if( ns.size() <= 5 )
        {
            bout << "\t" << "return ";
            for( Ast::NodeRefSet::const_iterator j = ns.begin(); j != ns.end(); ++j )
            {
                if( j != ns.begin() )
                    bout << " || ";
                const Ast::Node* n = (*j).d_node;
                bout << "tt == Tok_" << GenUtils::symToString(n->d_tok.d_val.toStr());
            }
            bout << ";" << endl;
        }else
        {
            bout << "\t" << "switch(tt){" << endl;
            for( Ast::NodeRefSet::const_iterator j = ns.begin(); j != ns.end(); ++j )
            {
                const Ast::Node* n = (*j).d_node;
                bout << "\t" << "case Tok_" << GenUtils::symToString(n->d_tok.d_val.toStr()) << ":" << endl;
            }
            bout << "\t\t" << "return true;" << endl;
            bout << "\t" << "default: return false;" << endl;
            bout << "\t" << "}" << endl;
        }
        bout << "}" << endl << endl;
    }

    bout << "void Parser::RunParser() {" << endl;
    bout << "\t" << "root = SynTree();" << endl;
    bout << "\t" << "errors.clear();" << endl;
    bout << "\t" << "next();" << endl;
    if( !syn->getOrderedDefs().isEmpty() )
    {
        const Ast::Definition* d = syn->getOrderedDefs().first();
        bout << "\t" << d->d_tok.d_val.toBa() << "(&root);" << endl;
    }
    bout << "}" << endl << endl;

    bout << "void Parser::next() {" << endl;
    bout << "\t" << "cur = la;" << endl;
    bout << "\t" << "la = scanner->next();" << endl;
    bout << "\t" << "while( la.d_type == Tok_Invalid ) {" << endl;
    bout << "\t\t" << "errors << Error(la.d_val, la.d_lineNr, la.d_colNr, la.d_sourcePath);" << endl;
    bout << "\t\t" << "la = scanner->next();" << endl;
    bout << "\t" << "}" << endl;
    bout << "}" << endl << endl;

    bout << "int Parser::peek(int off) {" << endl;
    bout << "\t" << "if( off == 1 )" << endl;
    bout << "\t\t" << "return la.d_type;" << endl;
    bout << "\t" << "else if( off == 0 )" << endl;
    bout << "\t\t" << "return cur.d_type;" << endl;
    bout << "\t" << "else" << endl;
    bout << "\t\t" << "return scanner->peek(off-1).d_type;" << endl;
    bout << "}" << endl << endl;

    bout << "void Parser::invalid(const char* what) {" << endl;
    // TODO
    bout << "}" << endl << endl;

    bout << "void Parser::expect(int tt, const char* where) {" << endl;
    bout << "\t" << "if( la.d_type == tt) next(); " << endl;
    bout << "\t" << "else errors << Error(QString(\"'%1' expected in %2\")"
            ".arg(tokenTypeString(tt)).arg(where),"
            "la.d_lineNr, la.d_colNr, la.d_sourcePath);" << endl;
    bout << "}" << endl << endl;

    for( int i = 0; i < syn->getOrderedDefs().size(); i++ )
    {
        const Ast::Definition* d = syn->getOrderedDefs()[i];

        if( d->d_tok.d_op == EbnfToken::Skip || ( i != 0 && d->d_usedBy.isEmpty() ) )
            continue;
        if( d->d_node == 0 || d->d_tok.d_op == EbnfToken::Transparent )
            continue;

        bout << "void Parser::" << d->d_tok.d_val.toStr() << "(SynTree* st) {" << endl;
        writeNode( bout, d->d_node, 0 );
        bout << "}" << endl << endl;
    }


    return true;
}

static inline QByteArray ws(int level)
{
    return QByteArray(level+1,'\t');
}

void CppGen::writeCond( QTextStream& out, bool loop, const QList<const Ast::Node*>& firsts )
{
    out << (loop ? "while" : "if") << "( ";
    for( int i = 0; i < firsts.size(); i++ )
    {
        if( i != 0 )
            out << " || ";
        const Ast::Node* n = firsts[i];
        switch( n->d_type )
        {
        case Ast::Node::Terminal:
            out << "la.d_type == Tok_" << GenUtils::symToString( n->d_tok.d_val.toStr() );
            break;
        case Ast::Node::Nonterminal:
            if( n->d_def == 0 || n->d_def->d_node == 0 )
                // this looks like a nt but is actually a terminal,
                // e.g. a token like ident, unsigned_real, decimal_int, etc.
                out << "la.d_type == Tok_" << GenUtils::symToString( n->d_tok.d_val.toStr() );
            else
                out << "FIRST_" << GenUtils::symToString( n->d_tok.d_val.toStr() ) << "(la.d_type)";
            break;
        case Ast::Node::Predicate:
            handlePredicate(out, n);
            break;
        }
    }
    out << " ) {" << endl;
}

void CppGen::writeNode(QTextStream& out, Ast::Node* node, int level)
{
    if( node == 0 )
        return;

    if( node->d_tok.d_op == EbnfToken::Skip )
        return;
    if( node->d_def && node->d_def->d_tok.d_op == EbnfToken::Skip )
        return;

#if 0
    if( !node->d_tok.d_val.isEmpty() )
        qDebug() << "writeNode" << node->d_tok.d_val.toBa() << level;
    else
        qDebug() << "writeNode <" << Ast::Node::s_typeName[node->d_type] << ">";
#endif
    switch( node->d_quant )
    {
    case Ast::Node::One:
        break;
    case Ast::Node::ZeroOrOne:
        out << ws(level);
        writeCond(out, false, findFirstsOf(node));
        level++;
        break;
    case Ast::Node::ZeroOrMore:
        out << ws(level);
        writeCond(out, true, findFirstsOf(node));
        level++;
        break;
    }

    switch( node->d_type )
    {
    case Ast::Node::Terminal:
        out << ws(level) << "expect(Tok_" << GenUtils::symToString( node->d_tok.d_val.toStr() )
            << ", \"" << node->d_owner->d_tok.d_val.toBa() << "\");" << endl;
        break;
    case Ast::Node::Nonterminal:
        if( node->d_def == 0 || node->d_def->d_node == 0 )
            // this looks like a nt but is actually a terminal,
            // e.g. a token like ident, unsigned_real, decimal_int, etc.
            out << ws(level) << "expect(Tok_" << GenUtils::symToString( node->d_tok.d_val.toStr() )
                << ", \"" << node->d_owner->d_tok.d_val.toBa() << "\");" << endl;
        else
            out << ws(level) << GenUtils::symToString(node->d_tok.d_val.toStr()) << "(st);" << endl;
        break;
    case Ast::Node::Alternative:
        for( int i = 0; i < node->d_subs.size(); i++ )
        {
            if( i != 0 )
                out << ws(level) << "} else ";
            else
                out << ws(level);
            writeCond(out, false, findFirstsOf(node->d_subs[i]));
            writeNode( out, node->d_subs[i], level+1 );
        }
        out << ws(level) << "} else" << endl;
        out << ws(level+1) << "invalid(\"" << node->d_owner->d_tok.d_val.toBa() << "\");" << endl;
        break;
    case Ast::Node::Sequence:
        for( int i = 0; i < node->d_subs.size(); i++ )
            writeNode( out, node->d_subs[i], level );
        break;
    case Ast::Node::Predicate:
        // qWarning() << "Coco::writeNode: Ast::Node::Predicate";
        break;
    }

    switch( node->d_quant )
    {
    case Ast::Node::One:
        break;
    case Ast::Node::ZeroOrMore:
    case Ast::Node::ZeroOrOne:
        out << ws(level-1) << "}" << endl;
        break;
    }
}

static void renderLaSub( QTextStream& out, const LaParser::Ast* ast, EbnfSyntax* syn, int la )
{
    switch( ast->d_type )
    {
    case LaParser::Ast::Ident:
        out << "peek(" << la << ") == " << "Tok_" << GenUtils::symToString(ast->d_val) << " ";
        break;
    case LaParser::Ast::Literal:
        out << "peek(" << la << ") == " << "Tok_" << GenUtils::symToString(ast->d_val) << " ";
        break;
    case LaParser::Ast::Not:
        out << "!( ";
        renderLaSub(out,ast->d_subs.first().data(),syn,la);
        out << ") ";
        break;
    case LaParser::Ast::Or:
        if( ast->d_subs.size() > 1 )
            out << "( ";
        for( int i = 0; i < ast->d_subs.size(); i++ )
        {
             if( i != 0 )
                 out << "|| ";
             renderLaSub(out,ast->d_subs[i].data(),syn, la);
        }
        if( ast->d_subs.size() > 1 )
            out << ") ";
        break;
    case LaParser::Ast::And:
        for( int i = 0; i < ast->d_subs.size(); i++ )
        {
             if( i != 0 )
                 out << "&& ";
             renderLaSub(out,ast->d_subs[i].data(),syn,la);
        }
        break;
    default:
        Q_ASSERT( false );
        break;
    }
}

static void renderLaExpr( QTextStream& out, const LaParser::Ast* ast, EbnfSyntax* syn )
{
    switch( ast->d_type )
    {
    case LaParser::Ast::La:
        renderLaSub( out,ast->d_subs.first().data(),syn,ast->d_val.toInt() );
        break;
    case LaParser::Ast::Or:
        if( ast->d_subs.size() > 1 )
            out << "( ";
        for( int i = 0; i < ast->d_subs.size(); i++ )
        {
             if( i != 0 )
                 out << "|| ";
             renderLaExpr(out,ast->d_subs[i].data(),syn);
        }
        if( ast->d_subs.size() > 1 )
            out << ") ";
        break;
    case LaParser::Ast::And:
        for( int i = 0; i < ast->d_subs.size(); i++ )
        {
             if( i != 0 )
                 out << "&& ";
             renderLaExpr(out,ast->d_subs[i].data(),syn);
        }
        break;
    default:
        Q_ASSERT( false );
        break;
    }
}

void CppGen::handlePredicate(QTextStream& out, const Ast::Node* pred)
{
    const QByteArray la = pred->getLa();
    if( !la.isEmpty() )
    {
        LaParser p;
        if( !p.parse(la) )
            return; // error was already reported

        out << "( ";
        renderLaExpr( out, p.getLaExpr().constData(), d_syn );
        out << ") ";

        return;
    }
    const int ll = pred->getLlk();
    if( ll > 0 )
    {
        EbnfAnalyzer::LlkNodes llkNodes;
        EbnfAnalyzer::calcLlkFirstSet( ll, llkNodes,pred->d_parent, d_tbl );
        //EbnfAnalyzer::calcLlkFirstSet2( ll, llkNodes,sequence, d_tbl );
        if( llkNodes.isEmpty() )
            return;
        out << "( ";
        for( int i = 0; i < llkNodes.size(); i++ )
        {
            if( i != 0 )
                out << "&& ";
            if( llkNodes[i].size() > 1 )
                out << "( ";
            QStringList names;
            Ast::NodeRefSet::const_iterator j;
            for( j = llkNodes[i].begin(); j != llkNodes[i].end(); ++j )
                names << "Tok_" + GenUtils::symToString( (*j).d_node->d_tok.d_val.toStr() );
            names.sort(Qt::CaseInsensitive);
            if( names.isEmpty() )
                out << "false ";
            else
                for( int j = 0; j < names.size(); j++ )
                {
                    if( j != 0 )
                        out << "|| ";
                    out << "peek(" << i+1 << ") == " << names[j] << " ";
                }
            if( llkNodes[i].size() > 1 )
                out << ") ";
        }
        out << ") ";
    }else
        qWarning() << "CocoGen unknown predicate" << pred->d_tok.d_val.toStr();
}

QList<const Ast::Node*> CppGen::findFirstsOf(Ast::Node* node) const
{
    QList<const Ast::Node*> res;
    switch( node->d_type )
    {
    case Ast::Node::Terminal:
    case Ast::Node::Nonterminal:
        res.append(node);
        return res;
    case Ast::Node::Predicate:
        break;
    }
    Q_ASSERT( node->d_type == Ast::Node::Alternative || node->d_type == Ast::Node::Sequence );
    for( int i = 0; i < node->d_subs.size(); i++ )
    {
        Ast::Node* sub = node->d_subs[i];

        if( sub->d_tok.d_op == EbnfToken::Skip )
            continue;
        if( sub->d_def && sub->d_def->d_tok.d_op == EbnfToken::Skip )
            continue;

        switch( sub->d_type )
        {
        case Ast::Node::Predicate:
            Q_ASSERT( node->d_type == Ast::Node::Sequence && res.isEmpty() );
            res.append(sub);
            return res;
        case Ast::Node::Terminal:
        case Ast::Node::Nonterminal:
            res.append(sub);
            break;
        case Ast::Node::Alternative:
        case Ast::Node::Sequence:
            res += findFirstsOf(sub);
            break;
        }

        if( node->d_type == Ast::Node::Alternative && sub->d_quant != Ast::Node::One )
        {
            // apparently nullable
            res += d_tbl->getFollowNodeSet(sub).toList();
        }else if( node->d_type == Ast::Node::Sequence )
        {
            if( sub->d_quant == Ast::Node::One )
                break; // stop after the first non-optional
            else if( i == node->d_subs.size()-1 )
            {
                // apparently nullable
                res += d_tbl->getFollowNodeSet(sub).toList();
            }
        }
    }
    return res;
}


